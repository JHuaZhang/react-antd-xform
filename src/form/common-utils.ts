// import * as mobx from 'mobx';
// import { useState } from 'react';

// // ================ 类型声明 ================
// export type ValueShape = 'array' | 'object';

// // ================ 工具函数实现 ================
// function isNumericKey(key: string): boolean {
//   return String(Number.parseInt(key)) === key;
// }

// export function keyToValueShape(key: string): ValueShape {
//   return isNumericKey(key) ? 'array' : 'object';
// }

// /** 合并两个值，优先使用第一个非 undefined 的值 */
// export function composeValue<T>(first: T, second: T): T {
//   return first !== undefined ? first : second;
// }

// export function splitToPath(name: number | string): string[] {
//   return String(name).split('.');
// }

// /** lodash.get 的 MobX 可观察对象版本 */
// export function observableGetIn(
//   obj: any,
//   key: string | string[],
//   defaultValue?: any,
// ): any {
//   const path = Array.isArray(key) ? key : splitToPath(key);
//   let target = obj;

//   for (let i = 0; i < path.length; i += 1) {
//     if (!mobx.isObservable(target)) {
//       return defaultValue;
//     }
//     target = mobx.get(target, path[i]);
//   }

//   return target === undefined ? defaultValue : target;
// }

// /** lodash.set 的 MobX 可观察对象版本 */
// export function observableSetIn(
//   obj: unknown,
//   key: string | string[],
//   value: unknown,
// ): void {
//   const path = Array.isArray(key) ? key : splitToPath(key);
//   const lastPartIndex = path.length - 1;
//   let currentTarget: any = obj;

//   for (let i = 0; i < lastPartIndex; i += 1) {
//     const part = path[i];
//     // 使用currentTarget代替target
//     if (mobx.get(currentTarget, part) === null) {
//       mobx.set(currentTarget, part, isNumericKey(path[i + 1]) ? [] : {});
//     }
//     // 添加类型断言解决重载匹配问题
//     currentTarget = mobx.get(currentTarget, part) as
//       | Record<string, any>
//       | any[];
//     if (!mobx.isObservable(currentTarget)) return;
//   }

//   if (mobx.isObservable(currentTarget)) {
//     mobx.set(currentTarget, path[lastPartIndex], value);
//   }
// }

// // ================ React Hooks ================
// function generateRandomId(len: number): string {
//   const byteToHex = (byte: number) => ('0' + byte.toString(16)).slice(-2);
//   const arr = new Uint8Array(len / 2);
//   window.crypto.getRandomValues(arr);
//   return Array.from(arr, byteToHex).join('');
// }

// export function useHtmlIdPrefix(htmlIdPrefixProp?: string): string {
//   const [autoGeneratedPrefix] = useState(() => `xform_${generateRandomId(6)}.`);
//   return htmlIdPrefixProp ?? autoGeneratedPrefix;
// }

// // ================ 工具函数 ================
// export const range = (n: number): number[] => {
//   const result: number[] = [];
//   for (let i = 0; i < n; i++) {
//     result.push(i);
//   }
//   return result;
// };

import * as mobx from 'mobx';
import { useState } from 'react';

function isNumericKey(key: string) {
  return String(Number.parseInt(key)) === key;
}

export function keyToValueShape(key: string) {
  return isNumericKey(key) ? 'array' : 'object';
}

/** lodash.get(...) for mobx observables */
export function observableGetIn(
  obj: any,
  key: string | string[],
  defaultValue?: any,
) {
  const path = Array.isArray(key) ? key : splitToPath(key);

  let target = obj;

  for (let i = 0; i < path.length; i += 1) {
    if (!mobx.isObservable(target)) {
      return defaultValue;
    }
    target = mobx.get(target, path[i]);
  }
  if (target === undefined) {
    return defaultValue;
  }
  return target;
}

/** lodash.set(...) for mobx observables */
export function observableSetIn(
  obj: unknown,
  key: string | string[],
  value: unknown,
) {
  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  const path = Array.isArray(key) ? key : splitToPath(key);
  const lastPartIndex = path.length - 1;

  let target = obj;

  for (let i = 0; i < lastPartIndex; i += 1) {
    const part = path[i];
    if (mobx.get(target, part) == null) {
      if (isNumericKey(path[i + 1])) {
        mobx.set(target, part, []);
      } else {
        mobx.set(target, part, {});
      }
    }
    target = mobx.get(target, part);
    if (!mobx.isObservable(target)) {
      return;
    }
  }
  if (mobx.isObservable(target)) {
    mobx.set(target, path[lastPartIndex], value);
  }
}

/** 合并两个值，如果第一个不为 undefined，则使用第一个值，否则使用第二个值 */
export function composeValue<T>(first: T, second: T) {
  if (first !== undefined) {
    return first;
  }
  return second;
}

export function splitToPath(name: number | string) {
  return String(name).split('.');
}

function generateRandomId(len: number) {
  const byteToHex = (byte: number) => ('0' + byte.toString(16)).slice(-2);
  const arr = new Uint8Array(len / 2);
  window.crypto.getRandomValues(arr);
  return Array.from(arr, byteToHex).join('');
}

export function useHtmlIdPrefix(htmlIdPrefixProp?: string) {
  const [autoGeneratedPrefix] = useState(() => `xform_${generateRandomId(6)}.`);

  if (htmlIdPrefixProp !== undefined) {
    return htmlIdPrefixProp;
  }

  return autoGeneratedPrefix;
}

export const range = (n: number) => {
  const result: number[] = [];
  for (let i = 0; i < n; i++) {
    result.push(i);
  }
  return result;
};
